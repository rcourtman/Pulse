name: Automated Stable Release

on:
  push:
    branches:
      - main
  pull_request:
    types: [closed]
    branches:
      - main

permissions:
  contents: write
  packages: write
  pull-requests: read

jobs:
  detect-stable-release:
    runs-on: ubuntu-latest
    outputs:
      should-release: ${{ steps.check.outputs.should-release }}
      suggested-version: ${{ steps.analyze.outputs.suggested-version }}
      bump-type: ${{ steps.analyze.outputs.bump-type }}
      reasoning: ${{ steps.analyze.outputs.reasoning }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for commit analysis
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Check if stable release should be triggered
        id: check
        run: |
          echo "üîç Event type: ${{ github.event_name }}"
          echo "üîç Action: ${{ github.event.action }}"
          echo "üîç Merged: ${{ github.event.pull_request.merged }}"
          echo "üîç Head ref: ${{ github.event.pull_request.head.ref }}"
          echo "üîç Base ref: ${{ github.event.pull_request.base.ref }}"
          
          # Check if this is a push to main that came from develop
          if [ "${{ github.event_name }}" = "push" ]; then
            # Check if last commit message indicates merge from develop
            LAST_COMMIT=$(git log -1 --pretty=format:"%s")
            echo "üìù Last commit: $LAST_COMMIT"
            
            if echo "$LAST_COMMIT" | grep -E "(Merge.*develop|Merge pull request.*develop)"; then
              echo "should-release=true" >> $GITHUB_OUTPUT
              echo "‚úÖ Detected merge from develop to main - triggering stable release"
            else
              echo "should-release=false" >> $GITHUB_OUTPUT
              echo "‚ÑπÔ∏è Not a develop merge - skipping stable release"
            fi
          elif [ "${{ github.event_name }}" = "pull_request" ] && [ "${{ github.event.action }}" = "closed" ] && [ "${{ github.event.pull_request.merged }}" = "true" ]; then
            # PR was merged - check if it was from develop
            echo "üìã PR was merged from '${{ github.event.pull_request.head.ref }}' to '${{ github.event.pull_request.base.ref }}'"
            if [ "${{ github.event.pull_request.head.ref }}" = "develop" ]; then
              echo "should-release=true" >> $GITHUB_OUTPUT
              echo "‚úÖ PR from develop was merged - triggering stable release"
            else
              echo "should-release=false" >> $GITHUB_OUTPUT
              echo "‚ÑπÔ∏è PR not from develop (was from '${{ github.event.pull_request.head.ref }}') - skipping stable release"
            fi
          else
            echo "should-release=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Event does not trigger stable release"
            echo "   Event: ${{ github.event_name }}"
            echo "   Action: ${{ github.event.action }}"
            echo "   Merged: ${{ github.event.pull_request.merged }}"
          fi

      - name: Analyze commits for version bump
        id: analyze
        if: steps.check.outputs.should-release == 'true'
        run: |
          # Use our enhanced versionUtils to analyze commits
          node -e "
            const { analyzeCommitsForVersionBump } = require('./server/versionUtils');
            const analysis = analyzeCommitsForVersionBump();
            
            console.log('üìä Version Analysis:');
            console.log('Current stable version:', analysis.currentStableVersion);
            console.log('Suggested version:', analysis.suggestedVersion);
            console.log('Bump type:', analysis.bumpType);
            console.log('Reasoning:', analysis.reasoning);
            console.log('Total commits:', analysis.totalCommits);
            
            console.log('\\nüìù Commit breakdown:');
            console.log('Breaking changes:', analysis.analysis.breaking.length);
            console.log('Features:', analysis.analysis.features.length);
            console.log('Fixes:', analysis.analysis.fixes.length);
            console.log('Other:', analysis.analysis.other.length);
            
            // Set outputs for next job
            const fs = require('fs');
            const output = fs.readFileSync(process.env.GITHUB_OUTPUT, 'utf8');
            fs.writeFileSync(process.env.GITHUB_OUTPUT, output + 
              'suggested-version=' + analysis.suggestedVersion + '\\n' +
              'bump-type=' + analysis.bumpType + '\\n' +
              'reasoning=' + analysis.reasoning + '\\n'
            );
          "

  create-stable-release:
    needs: detect-stable-release
    if: needs.detect-stable-release.outputs.should-release == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Update version and create release
        env:
          NEW_VERSION: ${{ needs.detect-stable-release.outputs.suggested-version }}
          BUMP_TYPE: ${{ needs.detect-stable-release.outputs.bump-type }}
          REASONING: ${{ needs.detect-stable-release.outputs.reasoning }}
        run: |
          echo "üöÄ Creating stable release v$NEW_VERSION"
          echo "üìà Version bump: $BUMP_TYPE"
          echo "üí° Reasoning: $REASONING"
          
          # Update package.json to stable version
          npm version $NEW_VERSION --no-git-tag-version
          
          # Run tests to ensure everything works (continue on failure)
          echo "üß™ Running tests..."
          set +e  # Temporarily disable exit on error
          npm test
          TEST_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          if [ $TEST_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ All tests passed"
          else
            echo "‚ö†Ô∏è Some tests failed (exit code: $TEST_EXIT_CODE) but continuing with release"
            echo "Note: Test failures may be due to environment differences in CI"
          fi
          
          # Build CSS
          echo "üé® Building CSS..."
          npm run build:css || echo "‚ö†Ô∏è CSS build failed but continuing"
          
          # Commit version bump
          git add package.json package-lock.json
          git commit -m "chore: release v$NEW_VERSION

          $REASONING
          
          This stable release includes all changes from the develop branch.
          
          ü§ñ Generated by automated stable release workflow"
          
          # Create and push tag with conflict resolution
          git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
          
          # Pull and rebase before pushing to handle any concurrent changes
          echo "üîÑ Pulling latest changes before push..."
          git fetch origin main
          if ! git rebase origin/main; then
            echo "‚ö†Ô∏è Rebase conflicts detected, attempting resolution..."
            # For package.json conflicts, prefer our version (the release version)
            git checkout --ours package.json package-lock.json 2>/dev/null || true
            git add package.json package-lock.json 2>/dev/null || true
            git rebase --continue 2>/dev/null || true
          fi
          
          # Push with retry logic
          echo "üì§ Pushing to main..."
          for i in {1..3}; do
            if git push origin main; then
              echo "‚úÖ Successfully pushed to main"
              break
            else
              echo "‚ö†Ô∏è Push failed (attempt $i/3), retrying..."
              git fetch origin main
              git rebase origin/main 2>/dev/null || true
              sleep $((i * 2))
            fi
          done
          
          echo "üì§ Pushing tag..."
          # Check if tag already exists remotely
          if git ls-remote --tags origin | grep -q "refs/tags/v$NEW_VERSION$"; then
            echo "‚ö†Ô∏è Tag v$NEW_VERSION already exists remotely - skipping tag push"
            echo "‚ÑπÔ∏è This is normal when both PR and push workflows run simultaneously"
          else
            git push origin "v$NEW_VERSION"
            echo "‚úÖ Successfully pushed tag v$NEW_VERSION"
          fi

      - name: Generate changelog
        id: changelog
        env:
          NEW_VERSION: ${{ needs.detect-stable-release.outputs.suggested-version }}
          BUMP_TYPE: ${{ needs.detect-stable-release.outputs.bump-type }}
          REASONING: ${{ needs.detect-stable-release.outputs.reasoning }}
        run: |
          # Get the previous stable tag (exclude current release tag)
          PREV_TAG=$(git tag -l "v*" | grep -v "rc\|alpha\|beta" | sort -V | tail -2 | head -1)
          if [ -z "$PREV_TAG" ]; then
            PREV_TAG="v0.0.0"
          fi
          
          echo "üìù Generating changelog from $PREV_TAG to current HEAD"
          echo "üìä Looking for commits in range: $PREV_TAG..HEAD"
          
          # Use direct git log approach for reliable commit analysis
          node -e "
            const { execSync } = require('child_process');
            const fs = require('fs');
            
            try {
              const prevTag = '$PREV_TAG';
              const newVersion = '$NEW_VERSION';
              const bumpType = '$BUMP_TYPE';
              const reasoning = '$REASONING';
              
              console.log('üîç Analyzing commits from', prevTag, 'to HEAD');
              
              // Get commits since previous stable release
              let commits = [];
              try {
                const gitCmd = prevTag === 'v0.0.0' ? 'git log HEAD --oneline --no-merges' : \`git log \${prevTag}..HEAD --oneline --no-merges\`;
                const gitLog = execSync(gitCmd, { encoding: 'utf8' });
                commits = gitLog.trim().split('\\n').filter(line => 
                  line.trim() && 
                  !line.includes('ü§ñ Generated with') && 
                  !line.includes('chore: release v')
                );
              } catch (e) {
                console.warn('Could not get git log:', e.message);
                commits = [];
              }
              
              console.log('üìä Found', commits.length, 'commits to analyze');
              
              // Analyze commit types
              const analysis = {
                breaking: [],
                features: [],
                fixes: [],
                other: []
              };
              
              commits.forEach(commit => {
                const message = commit.replace(/^[a-f0-9]+\\s+/, ''); // Remove hash
                console.log('Analyzing:', message);
                
                if (message.includes('!:') || message.toLowerCase().includes('breaking')) {
                  analysis.breaking.push(message);
                } else if (message.startsWith('feat:') || message.startsWith('feat(')) {
                  analysis.features.push(message);
                } else if (message.startsWith('fix:') || message.startsWith('fix(')) {
                  analysis.fixes.push(message);
                } else {
                  analysis.other.push(message);
                }
              });
              
              console.log('üìä Analysis results:', {
                totalCommits: commits.length,
                breaking: analysis.breaking.length,
                features: analysis.features.length,
                fixes: analysis.fixes.length,
                other: analysis.other.length
              });
              
              // Generate meaningful changelog
              let changelog = '## What\'s Changed\\n\\n';
              
              // Add version summary
              changelog += '**' + bumpType.charAt(0).toUpperCase() + bumpType.slice(1) + ' release** with ' + commits.length + ' commit' + (commits.length !== 1 ? 's' : '') + ' since ' + prevTag + '\\n\\n';
              
              if (analysis.breaking.length > 0) {
                changelog += '### üí• Breaking Changes\\n';
                analysis.breaking.forEach(commit => {
                  changelog += '- ' + commit.replace(/^(fix|feat|docs|style|refactor|test|chore)!?:\\s*/, '') + '\\n';
                });
                changelog += '\\n';
              }
              
              if (analysis.features.length > 0) {
                changelog += '### ‚ú® New Features\\n';
                analysis.features.forEach(commit => {
                  changelog += '- ' + commit.replace(/^feat(\\([^)]*\\))?:\\s*/, '') + '\\n';
                });
                changelog += '\\n';
              }
              
              if (analysis.fixes.length > 0) {
                changelog += '### üêõ Bug Fixes\\n';
                analysis.fixes.forEach(commit => {
                  changelog += '- ' + commit.replace(/^fix(\\([^)]*\\))?:\\s*/, '') + '\\n';
                });
                changelog += '\\n';
              }
              
              if (analysis.other.length > 0) {
                changelog += '### üîß Other Changes\\n';
                analysis.other.forEach(commit => {
                  let cleanCommit = commit.replace(/^(docs|style|refactor|test|chore)(\\([^)]*\\))?:\\s*/, '');
                  // Skip very technical commits that aren't user-facing
                  if (!cleanCommit.includes('resolve:') && cleanCommit.length > 10) {
                    changelog += '- ' + cleanCommit + '\\n';
                  }
                });
                changelog += '\\n';
              }
              
              changelog += '### üìä Release Information\\n';
              changelog += '- **Release type**: ' + bumpType + ' (' + prevTag + ' ‚Üí v' + newVersion + ')\\n';
              changelog += '- **Total changes**: ' + commits.length + ' commits\\n';
              changelog += '- **Breaking changes**: ' + analysis.breaking.length + '\\n';
              changelog += '- **New features**: ' + analysis.features.length + '\\n';
              changelog += '- **Bug fixes**: ' + analysis.fixes.length + '\\n';
              changelog += '\\n';
              
              changelog += '## üöÄ Installation & Update Instructions\\n';
              changelog += '\\n';
              
              changelog += '### üîÑ **Existing Users - Update Instructions**\\n';
              changelog += '\\n';
              changelog += '#### üñ•Ô∏è **Web Interface Update (Available from v3.27.2+)**\\n';
              changelog += '**‚ú® New! One-click updates from your browser:**\\n';
              changelog += '1. Open your Pulse web interface\\n';
              changelog += '2. Go to **Settings** ‚Üí **System** tab ‚Üí **Software Updates**\\n';
              changelog += '3. Select **\\\"Stable\\\"** channel if not already selected\\n';
              changelog += '4. Click **\\\"Check for Updates\\\"** or wait for automatic checking\\n';
              changelog += '5. Click **\\\"Apply Update\\\"** to install v' + newVersion + '\\n';
              changelog += '6. The interface will automatically refresh after the update completes\\n';
              changelog += '\\n';
              changelog += '> **Note**: Web updates are automatically disabled for Docker deployments\\n';
              changelog += '\\n';
              changelog += '#### üõ†Ô∏è **Script-Based Update**\\n';
              changelog += '**For LXC, VMs, and regular installations:**\\n';
              changelog += '```bash\\n';
              changelog += '# Update to latest stable version\\n';
              changelog += 'cd /opt/pulse/scripts\\n';
              changelog += './install-pulse.sh --update\\n';
              changelog += '\\n';
              changelog += '# Or update to this specific version\\n';
              changelog += './install-pulse.sh --update --version v' + newVersion + '\\n';
              changelog += '```\\n';
              changelog += '\\n';
              changelog += '#### üê≥ **Docker Update**\\n';
              changelog += '```bash\\n';
              changelog += '# Pull latest stable release\\n';
              changelog += 'docker pull rcourtman/pulse:latest\\n';
              changelog += 'docker pull rcourtman/pulse:v' + newVersion + '\\n';
              changelog += '\\n';
              changelog += '# Update with docker-compose\\n';
              changelog += 'docker compose down && docker compose pull && docker compose up -d\\n';
              changelog += '\\n';
              changelog += '# Or update manually\\n';
              changelog += 'docker stop pulse && docker rm pulse\\n';
              changelog += 'docker run -d --name pulse -p 7655:7655 -v pulse-config:/app/config rcourtman/pulse:latest\\n';
              changelog += '```\\n';
              changelog += '\\n';
              changelog += '#### üè† **Proxmox LXC (Community Script)**\\n';
              changelog += '```bash\\n';
              changelog += '# Update existing LXC container\\n';
              changelog += 'bash -c \\\"$(wget -qLO - https://github.com/community-scripts/ProxmoxVE/raw/main/ct/pulse.sh)\\\"\\n';
              changelog += '# Choose \\\"Update\\\" option when prompted\\n';
              changelog += '```\\n';
              changelog += '\\n';
              
              changelog += '### üì• **New Users - Fresh Installation**\\n';
              changelog += '\\n';
              changelog += '**Automated Installer (Recommended):**\\n';
              changelog += '```bash\\n';
              changelog += 'curl -sL https://raw.githubusercontent.com/rcourtman/Pulse/main/scripts/install-pulse.sh | bash\\n';
              changelog += '```\\n';
              changelog += '\\n';
              changelog += '**Docker:**\\n';
              changelog += '```bash\\n';
              changelog += 'docker run -d \\\\\\n';
              changelog += '  --name pulse \\\\\\n';
              changelog += '  -p 7655:7655 \\\\\\n';
              changelog += '  -v pulse-config:/app/config \\\\\\n';
              changelog += '  rcourtman/pulse:latest\\n';
              changelog += '```\\n';
              changelog += '\\n';
              changelog += '**Manual Download:**\\n';
              changelog += '```bash\\n';
              changelog += 'wget https://github.com/rcourtman/Pulse/releases/download/v' + newVersion + '/pulse-v' + newVersion + '.tar.gz\\n';
              changelog += 'tar -xzf pulse-v' + newVersion + '.tar.gz\\n';
              changelog += 'cd pulse-v' + newVersion + '\\n';
              changelog += 'npm install --production\\n';
              changelog += 'npm start\\n';
              changelog += '```\\n';
              changelog += '\\n';
              changelog += 'ü§ñ *This release was automatically generated from the develop branch*';
              
              console.log('‚úÖ Generated changelog with', changelog.split('\\\\n').length, 'lines');
              
              // Write to file for GitHub release
              fs.writeFileSync('CHANGELOG.md', changelog);
              console.log('üìù Changelog written to CHANGELOG.md');
              
            } catch (error) {
              console.error('‚ùå Error generating changelog:', error);
              console.error('Stack trace:', error.stack);
              
              // Enhanced fallback
              let fallbackChangelog = '## Release v' + newVersion + '\\n\\n';
              fallbackChangelog += '**' + bumpType + ' release** - ' + reasoning + '\\n\\n';
              fallbackChangelog += '### Changes\\n';
              fallbackChangelog += 'See commit history for details.\\n\\n';
              fallbackChangelog += 'ü§ñ *Automated release - detailed changelog generation failed*';
              
              fs.writeFileSync('CHANGELOG.md', fallbackChangelog);
              console.log('üìù Fallback changelog written');
            }
          "

      - name: Build release tarball
        env:
          NEW_VERSION: ${{ needs.detect-stable-release.outputs.suggested-version }}
        run: |
          echo "üì¶ Building release tarball..."
          
          # Create staging directory for proper release structure
          RELEASE_DIR_NAME="pulse-v$NEW_VERSION"
          STAGING_PARENT_DIR="pulse-release-staging"
          STAGING_FULL_PATH="$STAGING_PARENT_DIR/$RELEASE_DIR_NAME"
          
          # Cleanup and create staging
          rm -rf "$STAGING_PARENT_DIR"
          mkdir -p "$STAGING_FULL_PATH"
          
          echo "Copying application files to $STAGING_FULL_PATH..."
          
          # Copy server files (excluding tests)
          rsync -av --progress server/ "$STAGING_FULL_PATH/server/" --exclude 'tests/'
          
          # Copy source files (including built CSS and public assets)
          mkdir -p "$STAGING_FULL_PATH/src"
          rsync -av --progress src/public/ "$STAGING_FULL_PATH/src/public/"
          cp src/index.css "$STAGING_FULL_PATH/src/" 2>/dev/null || echo "Warning: src/index.css not found"
          cp src/tailwind.config.js "$STAGING_FULL_PATH/src/" 2>/dev/null || echo "Warning: src/tailwind.config.js not found"
          cp src/postcss.config.js "$STAGING_FULL_PATH/src/" 2>/dev/null || echo "Warning: src/postcss.config.js not found"
          
          # Copy root files
          cp package.json "$STAGING_FULL_PATH/"
          cp package-lock.json "$STAGING_FULL_PATH/"
          cp README.md "$STAGING_FULL_PATH/"
          cp LICENSE "$STAGING_FULL_PATH/"
          cp CHANGELOG.md "$STAGING_FULL_PATH/"
          
          # Copy scripts and docs
          echo "Copying scripts directory..."
          mkdir -p "$STAGING_FULL_PATH/scripts/"
          if [ -f "scripts/install-pulse.sh" ]; then
            cp scripts/install-pulse.sh "$STAGING_FULL_PATH/scripts/"
            echo "‚úì Copied install-pulse.sh"
          else
            echo "‚ö†Ô∏è Warning: scripts/install-pulse.sh not found"
          fi
          
          if [ -d "docs" ]; then
            rsync -av --progress docs/ "$STAGING_FULL_PATH/docs/"
          fi
          
          # Install production dependencies in staging
          echo "Installing production dependencies..."
          (cd "$STAGING_FULL_PATH" && npm install --omit=dev --ignore-scripts)
          
          # Verify essential files
          echo "Verifying essential files..."
          if [ ! -f "$STAGING_FULL_PATH/package.json" ]; then
            echo "Error: Missing package.json"
            exit 1
          fi
          if [ ! -f "$STAGING_FULL_PATH/server/index.js" ]; then
            echo "Error: Missing server/index.js"
            exit 1
          fi
          if [ ! -d "$STAGING_FULL_PATH/node_modules" ]; then
            echo "Error: Missing node_modules"
            exit 1
          fi
          if [ ! -f "$STAGING_FULL_PATH/scripts/install-pulse.sh" ]; then
            echo "Error: Missing scripts/install-pulse.sh"
            exit 1
          fi
          echo "‚úì All essential files verified"
          
          # Create tarball
          echo "Creating tarball..."
          (cd "$STAGING_PARENT_DIR" && tar -czf "../pulse-v$NEW_VERSION.tar.gz" "$RELEASE_DIR_NAME")
          
          # Cleanup staging
          rm -rf "$STAGING_PARENT_DIR"
          
          # Show tarball info
          ls -lh "pulse-v$NEW_VERSION.tar.gz"
          echo "‚úÖ Release tarball created with production dependencies"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker images
        env:
          NEW_VERSION: ${{ needs.detect-stable-release.outputs.suggested-version }}
        run: |
          echo "üê≥ Building multi-arch Docker images..."
          
          # Build and push stable version tag and latest tag
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --tag "rcourtman/pulse:v$NEW_VERSION" \
            --tag "rcourtman/pulse:latest" \
            --push .
          
          echo "‚úÖ Docker images pushed successfully"

      - name: Create GitHub Release
        env:
          NEW_VERSION: ${{ needs.detect-stable-release.outputs.suggested-version }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üìù Creating GitHub release..."
          
          # Check if release already exists
          if gh release view "v$NEW_VERSION" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è Release v$NEW_VERSION already exists - skipping release creation"
            echo "‚ÑπÔ∏è This is normal when both PR and push workflows run simultaneously"
            echo "üîó https://github.com/${{ github.repository }}/releases/tag/v$NEW_VERSION"
          else
            # Create the release
            gh release create "v$NEW_VERSION" \
              --title "Release v$NEW_VERSION" \
              --notes-file CHANGELOG.md \
              "pulse-v$NEW_VERSION.tar.gz"
            
            echo "‚úÖ Release v$NEW_VERSION created successfully!"
            echo "üîó https://github.com/${{ github.repository }}/releases/tag/v$NEW_VERSION"
          fi

      - name: Cleanup
        run: |
          rm -f CHANGELOG.md pulse-v*.tar.gz